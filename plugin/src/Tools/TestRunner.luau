--!strict
-- TestRunner: Run and manage test suites

local TreeWalker = require(script.Parent.Parent.Utils.TreeWalker)

local TestRunner = {}
local lastResults: any = nil

function TestRunner.run(args: { [string]: any }): (boolean, any, string?)
	local targetPath = args.path or ""
	local results: { any } = {}
	local passed = 0
	local failed = 0
	local errors = 0

	-- Find test scripts (convention: *.spec or *.test)
	local scripts = TreeWalker.collectScripts()
	local testScripts: { Instance } = {}

	for _, scriptInstance in ipairs(scripts) do
		local name = scriptInstance.Name:lower()
		if name:find("%.spec$") or name:find("%.test$") or name:find("test") then
			if targetPath == "" or scriptInstance:GetFullName():find(targetPath) then
				table.insert(testScripts, scriptInstance)
			end
		end
	end

	if #testScripts == 0 then
		return true, {
			message = "No test scripts found. Create scripts ending with .spec or .test",
			hint = "Use test_create to generate test templates",
		}, nil
	end

	for _, testScript in ipairs(testScripts) do
		local ok, source = pcall(function() return (testScript :: any).Source end)
		if not ok or not source then continue end

		-- Try to require and run the test module
		if testScript:IsA("ModuleScript") then
			local requireOk, testModule = pcall(require, testScript :: ModuleScript)
			if requireOk and type(testModule) == "table" then
				-- Run each test function
				for testName, testFn in pairs(testModule) do
					if type(testFn) == "function" and tostring(testName):find("test") then
						local runOk, runErr = pcall(testFn)
						if runOk then
							passed += 1
							table.insert(results, {
								test = testScript.Name .. "." .. testName,
								status = "PASS",
							})
						else
							failed += 1
							table.insert(results, {
								test = testScript.Name .. "." .. testName,
								status = "FAIL",
								error = tostring(runErr),
							})
						end
					end
				end
			else
				errors += 1
				table.insert(results, {
					test = testScript.Name,
					status = "ERROR",
					error = "Failed to require: " .. tostring(testModule),
				})
			end
		end
	end

	lastResults = {
		totalTests = passed + failed + errors,
		passed = passed,
		failed = failed,
		errors = errors,
		results = results,
		timestamp = os.time(),
	}

	return true, lastResults, nil
end

function TestRunner.create(args: { [string]: any }): (boolean, any, string?)
	local targetPath = args.target_path or args.targetPath
	if not targetPath then
		return false, nil, "target_path is required"
	end

	-- Find the target module
	local scripts = TreeWalker.collectScripts()
	local targetScript: Instance? = nil

	for _, scriptInstance in ipairs(scripts) do
		if scriptInstance:GetFullName():find(targetPath) then
			targetScript = scriptInstance
			break
		end
	end

	if not targetScript then
		return false, nil, "Script not found at path: " .. targetPath
	end

	-- Analyze the module to generate test template
	local ok, source = pcall(function() return (targetScript :: any).Source end)
	if not ok or not source then
		return false, nil, "Cannot read script source"
	end

	-- Extract function names
	local functions: { string } = {}
	for funcName in source:gmatch("function%s+%w+[%.:](%w+)") do
		table.insert(functions, funcName)
	end
	for funcName in source:gmatch("(%w+)%s*=%s*function") do
		table.insert(functions, funcName)
	end

	-- Generate test template
	local template = { "--!strict" }
	table.insert(template, "-- Auto-generated test for " .. targetScript.Name)
	table.insert(template, "-- Generated by StudioLink\n")
	table.insert(template, "local module = require(" .. targetPath .. ")\n")
	table.insert(template, "local Tests = {}\n")

	for _, funcName in ipairs(functions) do
		table.insert(template, "function Tests.test_" .. funcName .. "()")
		table.insert(template, "\t-- TODO: Add test for " .. funcName)
		table.insert(template, "\tlocal result = module." .. funcName .. "()")
		table.insert(template, "\tassert(result ~= nil, \"" .. funcName .. " should return a value\")")
		table.insert(template, "end\n")
	end

	table.insert(template, "return Tests")

	local testSource = table.concat(template, "\n")

	return true, {
		targetScript = targetScript:GetFullName(),
		testTemplate = testSource,
		functionsFound = functions,
		note = "Create a ModuleScript named '" .. targetScript.Name .. ".spec' and paste this template",
	}, nil
end

function TestRunner.report(args: { [string]: any }): (boolean, any, string?)
	if not lastResults then
		return true, "No test results available. Run test_run first.", nil
	end

	local lines = { "=== StudioLink Test Report ===" }
	table.insert(lines, string.format(
		"Total: %d | Passed: %d | Failed: %d | Errors: %d",
		lastResults.totalTests, lastResults.passed, lastResults.failed, lastResults.errors
	))
	table.insert(lines, "")

	for _, result in ipairs(lastResults.results) do
		local icon = if result.status == "PASS" then "[OK]"
			elseif result.status == "FAIL" then "[FAIL]"
			else "[ERR]"
		local line = icon .. " " .. result.test
		if result.error then
			line = line .. " â€” " .. result.error
		end
		table.insert(lines, line)
	end

	return true, table.concat(lines, "\n"), nil
end

return TestRunner
